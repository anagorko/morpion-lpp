#ifndef MORPION_LPP
#define MORPION_LPP

#include <map>
//#include "/opt/local/include/graphviz/cgraph.h"
#include "morpion.h"
#include "lpp.h"

/**
 * MorpionSolution extends Solution class by adding a method that plots
 * cycles in the solution graph.
 *
 * TODO: convert solution to Pentasol format
 *
 * TODO: read solution from file generated by Gurobi (.mst format, maybe others)
 */
 
class MorpionSolution : public Solution
{
public:
    void getGraph(std::string filename);
};

/**
 * BaseMorpionLPP.
 *
 * Contains methods to create board on which Morpion LPP is built.
 */
 
class BaseMorpionLPP : public LPP
{
protected:
    Board b;

    std::map<std::string,bool> f;
    std::map<std::string,int> v;
    
public:
    BaseMorpionLPP()
    {
        f.clear();
        v.clear();
    }
    
    const Board& getBoard() const { return b; }
    void setBoard(Board &_b) {
        b = _b;
        b.precompute();
    }

    void setFlag(std::string flag, bool value) { f[flag] = value; }
    bool getFlag(std::string flag) { 
        try {
            return f.at(flag);
        } catch (const std::out_of_range& oor) {
            return false;
        }
    }
    bool isFlagSet(std::string flag) { 
        return f.find(flag) != f.end();
    }

    int getValue(std::string name) {
        try {
            return v.at(name);
        } catch (const std::out_of_range& oor) {
            return -1;
        }
    }
    void setValue(std::string name, int value) { v[name] = value; }
    bool isValueSet(std::string name) {
        return v.find(name) != v.end();
    }
    
    std::string gameId()
    {
        std::stringstream ss;
        
        ss << "Morpion ";
        ss << b.getVariant();
        ss << " " << b.getWidth() << "x" << b.getHeight() << " R=" << b.getReference();

        // TODO: list all flags
        ss << (getFlag("symmetric") ? " symmetric" : "");
        ss << (getFlag("acyclic") ? " acyclic" : "");
        ss << (getFlag("bacyclic") ? " bool acyclic" : "");
        ss << (getFlag("exact") ? " exact" : " fuzzy");

        return ss.str();        
    }
    
    virtual LPP* getLPP() = 0;

    Constraint getSideConstraint(int coef_x, int coef_y, bool max) 
    {
        std::vector<Dot> side = b.getSide(coef_x, coef_y, max);
        
        Constraint c;
        
        c.setName("side_" + to_string(coef_x + 1) + "_" + to_string(coef_y + 1) +
                  "_" + (max ? "max" : "min"));

        for (const Dot& d: side) {
            c.addVariable("dot_" + to_string(d), 1.0);
        }
        
        c.setBound(1.0);
        c.setType(Constraint::GT);
        return c;
    }
};

/**
 *
 */
 
class MorpionLPP : public BaseMorpionLPP 
{
protected:    
    std::vector<Constraint> createCycleConstraints(Segment s1, int d2, int d3)
    {
        std::vector<Constraint> r;
        
        for (int l = 1; l <= 4; l++) {
            Constraint c;
            
            Segment s2;
            
            s2.first = s1.first + direction[s1.second] * l;
            s2.second = d2;
            
            Segment s3;
            
            s3.first = s2.first + direction[d2] * l;
            s3.second = d3;
            
            std::vector<Move> cycle;
            std::vector<Move> support;

            if (b.infeasibleDot(s1.first) || b.infeasibleDot(s2.first) || b.infeasibleDot(s3.first)) {
                continue;
            }
            
            if (b.hasDot(s1.first) || b.hasDot(s2.first) || b.hasDot(s3.first)) {
                continue;
            }
            
            for (const Move& m: b.getMovesPlacingSegment(s1)) {
                // does m remove s2 or s3?
                
                if (m.removesSegment(s2, b.getVariant()) || m.removesSegment(s3, b.getVariant())) {
                    cycle.push_back(m);
                } else {
                    support.push_back(m);
                }
            }

            for (const Move& m: b.getMovesPlacingSegment(s2)) {
                // does m remove s1 or s3?
                
                if (m.removesSegment(s1, b.getVariant()) || m.removesSegment(s3, b.getVariant())) {
                    cycle.push_back(m);
                } else {
                    support.push_back(m);
                }
            }

            for (const Move& m: b.getMovesPlacingSegment(s3)) {
                // does m remove s1 or s2?
                
                if (m.removesSegment(s1, b.getVariant()) || m.removesSegment(s2, b.getVariant())) {
                    cycle.push_back(m);
                } else {
                    support.push_back(m);
                }
            }
            
            for (const Move& m: cycle) {
                c.addVariable(to_string(m), 1.0);
            }
            for (const Move &m: support) {
                c.addVariable(to_string(m), -2.0);
            }
            c.setBound(0.0);
            c.setType(Constraint::LT);
            c.setName("sc_");
            
            r.push_back(c);
        }
        
        return r;
    }
    
public:
    LPP* getLPP();
};

class PlusPlusLPP : public BaseMorpionLPP
{
public:
    LPP* getLPP();
};

class CnLPP : public BaseMorpionLPP
{
    int n;
    
public:
    LPP* getLPP();
    void setN(int);
};

class PotentialLPP : public BaseMorpionLPP
{
    LPP* getLPP();
};

class TieredLPP : public BaseMorpionLPP
{
    LPP* getLPP();
};

#endif
